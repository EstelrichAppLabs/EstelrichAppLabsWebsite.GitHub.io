[{"section":"Blog","slug":"/blog/2025.07.13_switching-to-calendar-based-versioning/","title":"Switching to calendar-based versioning","description":"Goodbye 1.0.0, Hello 2025.1.0.","date":"July 13, 2025","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog-posts/calendar-based-versioning_hu_c3ab01ea3fbb3e9f.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog-posts\\/calendar-based-versioning_hu_9a103b2c13d72184.jpeg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog-posts/calendar-based-versioning_hu_485d7d64a03e4763.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog-posts\\/calendar-based-versioning_hu_99321fb8ee8d3d9a.jpeg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Opinion","tags":"Versioning, Release, CI/CD","content":"For years, I used semantic versioning (1.0.0, 1.1.0, 2.0.0, ..etc.) as the default way to track app releases. It made sense: major for breaking changes, minor for new features, patch for fixes. But the more I built and shipped across my career multiple companies and as an indie developer lately, the more I found myself questioning what those numbers were really telling me, or anyone else.\nSo, a few months ago I decided to switch. Since then, I have been using calendar-based versioning: 2025.0.0, 2025.1.0, and so on. It’s simpler, clearer, and frankly, a better reflection of how I work and release all kind of apps.\nWhy semantic versioning isn’t working for me Semantic versioning sounds great in theory. In practice, I found myself second-guessing every bump:\n“Is this a breaking change?” “Do I call this 1.1.0 or 2.0.0?” “Will users or clients even know what changed?” This emotional friction and time overhead can slow momentum, especially in small teams or solo projects where there isn’t a dedicated release manager. The constant debate over version semantics can lead to inconsistency, confusion, and sometimes unnecessary delays. Instead of focusing on shipping and iterating, a disproportionate amount of time gets spent on deciding how to number a release, which ultimately distracts from the product itself.\nWhy calendar versioning works better With calendar versioning, I use the year as the anchor:\n2025.0.0 is the first release of the year. 2025.5.0 reflects the number of sprints or releases that have happened up to that point. 2025.8.1 is a bug fix or quick patch. It aligns with how I plan my work. I think in terms of quarters and yearly goals, not abstract concepts like \u0026ldquo;major\u0026rdquo; or \u0026ldquo;minor\u0026rdquo; changes. And for users, it’s instantly understandable: a version from 2025 is obviously newer than one from 2024.\nBeyond development, this approach integrates well with marketing campaigns, project management timelines, and customer communication. It makes it easier to coordinate release announcements, track progress against business goals, and provide clear context to stakeholders who may not be familiar with semantic versioning nuances.\nIt’s not just about code This isn’t just a technical change, it’s also a mindset shift. I want versioning to reflect how I actually work and ship:\nI iterate fast. I prioritize clarity over theoretical correctness. I care more about momentum and transparency than rigid rules. Versioning should mirror the rhythm of the product and the velocity of the team, not just API compatibility or technical constraints. It’s about capturing the pace and flow of development in a way that feels natural and meaningful to everyone involved.\nWhen semantic versioning still makes sense Semantic versioning still has its place. Especially for libraries, SDKs, or APIs with downstream consumers who need to know exactly what’s going to break. For example, if I were maintaining a networking library used by multiple projects or companies, strict compatibility guarantees would be essential. In such cases, semantic versioning helps communicate breaking changes clearly and prevents integration issues.\nIf I ever publish a Swift package, I’ll probably stick to semantic versioning there.\nBut for apps, internal tools, or products I control end-to-end? Calendar versioning is just more practical.\nFinal thoughts This change might seem small, but it’s made versioning feel lighter, faster, and more aligned with how I actually develop. If you’re a developer tired of overthinking every version bump, give 2025.0.0 a try.\nFor indie developers and small teams especially, this approach can reduce overhead and help maintain momentum. Sometimes the best versioning system isn’t the most technically correct but the one that helps you keep building and moving forward with confidence.\n"},{"section":"Blog","slug":"/blog/2025.04.03_why-native-ios-2025/","title":"Why I still choose native iOS development in 2025","description":"A 2025 perspective on why native iOS development still stands strong against cross-platform trends like Flutter and React Native.","date":"April 3, 2025","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog-posts/keyboard-macro_hu_f6f25a5d37003bcc.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog-posts\\/keyboard-macro_hu_129b79e940a9ae9c.jpeg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog-posts/keyboard-macro_hu_b0c5401a567396ab.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog-posts\\/keyboard-macro_hu_649b06f0c288def3.jpeg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Opinion","tags":"Swift, Flutter, React Native, Kotlin","content":"In 2025, native iOS development often feels like a deliberate choice rather than the default. With the rise of cross-platform tools like Flutter, React Native, and Kotlin Multiplatform, engineering teams are under increasing pressure to \u0026ldquo;build once, run everywhere.\u0026rdquo; And while that pitch has appeal especially from a business perspective, I continue to invest deeply in native iOS development and here’s why.\nFirst-Class platform support Apple doesn’t just encourage native development, it designs for it. Whether it\u0026rsquo;s new APIs, platform features, or hardware integrations, the native toolchain (Swift, SwiftUI, UIKit, Xcode) always receives first access and most comprehensive support.\nTaking SwiftUI as a case of study. Each WWDC brings significant evolution to SwiftUI, and Apple’s frameworks consistently push toward a more declarative, native-first experience. If you\u0026rsquo;re building with anything else, you\u0026rsquo;re either waiting or working around limitations.\nFor apps that want to feel deeply integrated, whether it’s leveraging visionOS features, haptics, live activities, or the small nuances of navigation stacks, native gives you access to everything the platform has to offer as soon as it\u0026rsquo;s available.\nPerformance and UX consistency still matter Cross-platform frameworks have come a long way but for apps where responsiveness, smooth animations and deep OS integration are critical I honestly believe that native still wins.\nIt\u0026rsquo;s not just about frame rate. It’s about consistency handling edge gestures the way users expect. Integrating seamlessly with accessibility features or matching system theming and typography. These details are part of what make iOS apps feel iOS-like, and they’re difficult to fully replicate outside the native stack.\nWhen performance or polish becomes non-negotiable, native is still the practical choice.\nSwift is a strategic bet Swift has matured into a powerful, safe, and expressive language. The tooling and compiler improvements in the last few years have made Swift development faster and more stable than ever. And the ecosystem around Swift (including Swift Package Manager, Swift Concurrency, and SwiftData) keeps growing in a direction that favors long-term maintainability.\nSwift isn’t just good because it’s Apple’s language, it’s good on its own terms. It allows for rapid prototyping yet encourages structure and clarity. It scales well with team size and complexity. And for iOS developers, it\u0026rsquo;s the most future-proof choice.\nThe cost of cross-platform isn’t just technical One of the main arguments for going cross-platform is cost reduction. But that conversation often focuses solely on code reuse and ignores other factors—like team velocity, platform-specific bugs or long-term maintainability.\nIn my experience, building natively with iOS specialists enables faster iterations, fewer compromises and more predictable long-term support. You avoid the tension of fighting the framework and can instead focus on delivering real value to users.\nSometimes the most efficient path isn’t the one with the least code but the one with the fewest tradeoffs.\nFinal thoughts Native iOS development isn’t always the right choice but it remains a strong choice—especially when quality, platform integration and future-proofing matter.\nAs developers, we should choose tools that align with both our goals and our values. For me, continuing to build natively is not about resisting change, it’s about embracing the strengths of the platform I’m developing for.\n"}]